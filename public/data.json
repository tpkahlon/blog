{"metadata":{"tags":[]},"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"rv8g4s0yjblf"}},"id":"4XjDJnEsZKKUtzuFP2owgn","type":"Entry","createdAt":"2023-05-09T02:42:48.521Z","updatedAt":"2023-05-27T00:07:43.652Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment"}},"revision":6,"contentType":{"sys":{"type":"Link","linkType":"ContentType","id":"site"}},"locale":"en-US"},"fields":{"name":"Hello, I'm Tej. I'm a developer who enjoys indulging in chai, writing, and blogging. I have a passion for web development, gaming, and cricket. I'm thrilled to have the opportunity to meet you.","articles":[{"metadata":{"tags":[]},"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"rv8g4s0yjblf"}},"id":"10U6f7FQmmvijn0NsCZIjV","type":"Entry","createdAt":"2023-05-09T02:43:16.831Z","updatedAt":"2023-05-26T23:54:20.976Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment"}},"revision":26,"contentType":{"sys":{"type":"Link","linkType":"ContentType","id":"article"}},"locale":"en-US"},"fields":{"name":"#1 - Maximizing the potential of your old iPhone in 2023","slug":"maximizing-the-potential-of-your-old-iphone-in-2023","body":{"nodeType":"document","data":{},"content":[{"nodeType":"heading-2","data":{},"content":[{"nodeType":"text","value":"Introduction","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"In a fast-paced world where new gadgets are constantly emerging, it's easy to feel pressured to upgrade your smartphone every year. However, if you happen to own an iPhone 7 and are looking to extend its lifespan, there are several steps you can take to continue using it as a productive tool. By implementing a few maintenance routines, you can make the most of your older device without the need to invest in a new iPhone.","marks":[],"data":{}}]},{"nodeType":"heading-2","data":{},"content":[{"nodeType":"text","value":"Monthly media cleanup","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"One common issue faced by iPhone users is limited storage space, especially when it comes to storing photos and videos. To address this, a simple monthly cleanup routine can help free up space on your iPhone 7. All you need is a ","marks":[],"data":{}},{"nodeType":"text","value":"Lightning-to-USB cable","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and a PC running ","marks":[],"data":{}},{"nodeType":"text","value":"Windows 11","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":".","marks":[],"data":{}}]},{"nodeType":"heading-2","data":{},"content":[{"nodeType":"text","value":"Connecting your old iPhone to a PC","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Start by attaching your iPhone 7 to your PC using the lightning-to-USB cable. Once connected, open the ","marks":[],"data":{}},{"nodeType":"text","value":"Photos ","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":"app on your PC. In most cases, your Apple iPhone 7 will be recognized as an external device by the ","marks":[],"data":{}},{"nodeType":"text","value":"Photos","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" app.","marks":[],"data":{}}]},{"nodeType":"heading-2","data":{},"content":[{"nodeType":"text","value":"Importing Media Files","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Within the ","marks":[],"data":{}},{"nodeType":"text","value":"Photos","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" app, locate and click on your iPhone 7 to view all the images and videos stored on the device. Select all the media files you wish to transfer and move them to a new folder on your PC. This process ensures that your precious memories are safely backed up while freeing up space on your iPhone 7.","marks":[],"data":{}}]},{"nodeType":"heading-2","data":{},"content":[{"nodeType":"text","value":"Deleting Media Files","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Once the import is successful, it's time to remove the media files from your iPhone 7. Within the ","marks":[],"data":{}},{"nodeType":"text","value":"Photos","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" app, Select all the images and videos on your device and delete them. This step helps optimize your iPhone's storage capacity, allowing you to continue using it without worrying about running out of space.","marks":[],"data":{}}]},{"nodeType":"heading-2","data":{},"content":[{"nodeType":"text","value":"Saving Costs and Maintaining Control","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"One of the advantages of regularly transferring your photos and videos from your iPhone 7 to your PC is that you can avoid the need for paid cloud services such as Google Photos, Dropbox, or OneDrive. By relying on the ","marks":[],"data":{}},{"nodeType":"text","value":"Photos","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" app on PC and ensuring that your PC has a minimum of 500GB HDD (which is commonly available and affordable), you can save money on recurring cloud storage fees. Cloud services often require subscription plans that can add up over time. By taking advantage of the ","marks":[],"data":{}},{"nodeType":"text","value":"Photos","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" app and storing your media files locally on your PC, you have greater control over your data and can save money in the long run. Plus, with a large HDD capacity, you can continue to store your photos and videos without worrying about exceeding any storage limits.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Having your media files stored on your PC allows for easy accessibility  and organization. You can create specific folders and sub-folders to  categorize your photos and videos, making it simpler to locate and share  them whenever needed. Additionally, you can leverage various desktop  photo management software to further enhance the organization and  editing of your media files. Remember to regularly back up your PC to external storage devices. This ensures that your precious memories are safeguarded even in the event of any unforeseen hardware failures or accidents.","marks":[],"data":{}}]},{"nodeType":"heading-2","data":{},"content":[{"nodeType":"text","value":"Prioritize iCloud for Essential Apps","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"If you have iCloud activated on your iPhone 7, it's important to ensure that the Photos sync feature is turned off. This allows you to utilize iCloud for backing up data from essential apps such as WhatsApp chats, contacts, phone calls and health monitoring data etc. By disabling the photo sync feature, you can optimize the available iCloud storage and allocate it to more crucial data.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Instead of using iCloud to store your photos and videos, leverage its capabilities to sync and back up data from important apps. This way, you can ensure that vital information is securely stored in the cloud without consuming excessive iCloud storage space. Review the apps you have enabled for iCloud backup and prioritize those that are crucial to your daily activities.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"If your iCloud storage is nearing its limit, it's important to review the content stored there and ensure that photos and videos are not taking up excessive space. If you discover that there are large files occupying your iCloud storage, promptly move them to your local PC using the ","marks":[],"data":{}},{"nodeType":"text","value":"Photos","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" app on PC. This practice helps optimize your iCloud storage and ensures that it is primarily used for essential app data.","marks":[],"data":{}}]},{"nodeType":"heading-2","data":{},"content":[{"nodeType":"text","value":"Future-Proofing Your Device","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"If you find yourself considering an upgrade from your existing phone, instead of chasing the latest and most expensive iPhone models on the market, explore the option of purchasing a used older version like the iPhone 7. You can often find these devices for less than $199, making them a budget-friendly choice.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"When searching for a used iPhone, aim for a model that offers maximum storage space, such as the ","marks":[],"data":{}},{"nodeType":"text","value":"128GB","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" variant. Having ample storage capacity becomes increasingly important as iOS security updates and app sizes continue to grow. By opting for a higher storage model, you ensure that your phone can comfortably handle the evolving demands of future software updates.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Choosing an older iPhone model with a generous storage capacity allows you to future-proof your device. As iOS updates become more substantial, having more storage space ensures that your phone remains capable of handling new features and security enhancements. This can extend the longevity of your device, allowing it to remain relevant and functional for the next decade.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Opting for a used iPhone not only saves you money but also allows you to leverage the reliability and performance of well-established models. Older iPhones often receive software updates for several years, providing you with the latest security patches and software optimizations. Moreover, purchasing a used iPhone from a reputable seller like ","marks":[],"data":{}},{"nodeType":"text","value":"FactoryDirect","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" etc. can provide you with a quality device that is thoroughly tested and verified.","marks":[],"data":{}}]},{"nodeType":"heading-2","data":{},"content":[{"nodeType":"text","value":"Conclusion","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"With a simple monthly maintenance routine, you can keep your iPhone 7 running smoothly and efficiently in 2023. By transferring and backing up your media files to a PC, you can ensure that your memories are safely preserved while optimizing the available storage space on your device. Don't feel pressured to invest in a new iPhone if your older device still meets your needs. Embrace the potential of your iPhone 7 and continue using it as a productive tool in your daily life.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Remember, it's not always about having the latest and greatest device; it's about how you make the most of what you already have. So, why not give your iPhone 7 a new lease on life and continue to enjoy its features and functionalities for years to come?","marks":[],"data":{}}]}]}}},{"metadata":{"tags":[]},"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"rv8g4s0yjblf"}},"id":"1Ql3caCLCaCsLSK2ixVPtT","type":"Entry","createdAt":"2023-05-22T21:23:19.684Z","updatedAt":"2023-05-22T21:26:51.374Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment"}},"revision":2,"contentType":{"sys":{"type":"Link","linkType":"ContentType","id":"article"}},"locale":"en-US"},"fields":{"name":"#2 - The most important NPM packages in the Contentful Ecosystem","slug":"the-most-important-npm-packages-in-the-contentful-ecosystem","body":{"nodeType":"document","data":{},"content":[{"nodeType":"heading-2","data":{},"content":[{"nodeType":"text","value":"Introduction","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"In this article, I will introduce you to some of the most essential NPM packages that are heavily used in the Contentful ecosystem. Familiarizing yourself with these packages will significantly simplify the process of developing applications that consume Contentful, allowing you to be more productive and efficient.","marks":[],"data":{}}]},{"nodeType":"heading-2","data":{},"content":[{"nodeType":"text","value":"Contentful","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"The first package we will explore is simply called ","marks":[],"data":{}},{"nodeType":"text","value":"Contentful","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". This package is indispensable when you want to interact with Content Delivery API or Content Preview API. It provides you with the capability to fetch content from these APIs and display it within your web application. With Contentful, you can seamlessly integrate and consume content stored in Contentful spaces.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"https://www.npmjs.com/package/contentful","marks":[{"type":"code"}],"data":{}}]},{"nodeType":"heading-2","data":{},"content":[{"nodeType":"text","value":"Contentful Management","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Next on our list is the ","marks":[],"data":{}},{"nodeType":"text","value":"contentful-management","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" package. This package enables you to interact with the Contentful system at a higher level. You can access system-level configurations and perform CRUD operations on data models. Contentful Management empowers you to programmatically manage and manipulate your content, offering you greater control and flexibility.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"https://www.npmjs.com/package/contentful-management","marks":[{"type":"code"}],"data":{}}]},{"nodeType":"heading-2","data":{},"content":[{"nodeType":"text","value":"Contentful CLI","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"The ","marks":[],"data":{}},{"nodeType":"text","value":"contentful-cli","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" package takes the Contentful experience a step further. It allows you to install a command-line interface (CLI) based script, enabling you to execute various operations on the Contentful system in the cloud. With the CLI, you can utilize flags and parameters to make changes such as running migrations, creating and removing environments, and more. The Contentful CLI streamlines your workflow and automates repetitive tasks.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"https://www.npmjs.com/package/contentful-cli","marks":[{"type":"code"}],"data":{}}]},{"nodeType":"heading-2","data":{},"content":[{"nodeType":"text","value":"Contentful Migration","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Next, we have the ","marks":[],"data":{}},{"nodeType":"text","value":"contentful-migration","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" package. This package plays a pivotal role in managing changes to content models in Contentful over the long term. By utilizing Contentful Migration, you can create a log of custom migration scripts that are executed on your site. These scripts track and document any modifications made to the content models, ensuring a systematic and traceable approach to managing your content structure.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"https://www.npmjs.com/package/contentful-migration","marks":[{"type":"code"}],"data":{}}]},{"nodeType":"heading-2","data":{},"content":[{"nodeType":"text","value":"Contentful Resolve Response","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"The ","marks":[],"data":{}},{"nodeType":"text","value":"contentful-resolve-response","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" package offers a valuable utility for parsing raw linked references. When working with Contentful, you often encounter linked references between entries. This package assists you in compiling the raw data and extracting the actual values stored in the fields of the linked references. It proves especially useful in specific use cases for your web application where resolving linked data is necessary.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"https://www.npmjs.com/package/contentful-resolve-response","marks":[{"type":"code"}],"data":{}}]},{"nodeType":"heading-2","data":{},"content":[{"nodeType":"text","value":"Conclusion","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"These five NPM packages are fundamental components of the Contentful ecosystem. Incorporating them into your development workflow will enhance your ability to interact with Contentful, streamline your processes, and boost productivity. Whether you're fetching content, managing data models, executing CLI operations, resolving linked references, or tracking content model changes, these packages will be invaluable assets in your Contentful toolkit. Embrace these tools and unlock the full potential of Contentful in your applications.","marks":[],"data":{}}]}]}}},{"metadata":{"tags":[]},"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"rv8g4s0yjblf"}},"id":"2hWrxkRPWR4bIBQuw5H0sH","type":"Entry","createdAt":"2023-05-23T21:19:31.805Z","updatedAt":"2023-05-24T02:50:13.786Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment"}},"revision":18,"contentType":{"sys":{"type":"Link","linkType":"ContentType","id":"article"}},"locale":"en-US"},"fields":{"name":"#3 - Mastering static marketing sites: A comprehensive guide to building efficient company websites with Contentful and Next.js","slug":"mastering-static-marketing-sites","body":{"nodeType":"document","data":{},"content":[{"nodeType":"heading-1","data":{},"content":[{"nodeType":"text","value":"Introduction","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"In this article, we will delve into the correct approach to building static marketing sites. I will guide you through the necessary steps to establish a solid foundation for your marketing site, ensuring easier long-term maintenance. Additionally, I will share valuable tips, tricks, and experiences derived from working in a multi-faceted team, where authors handle the site's content and developers manage its features. Our ultimate objective is to create a marketing site that is exceptionally fast, user-friendly for content management, and conducive to shipping new features. To achieve this, we will fully automate the entire process, encompassing content creation all the way to production deployment.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Furthermore, I will demonstrate how to utilize Next.js to build a static marketing site. Next.js has emerged as the industry standard for web development, providing a reliable code base for constructing static sites. We will explore the best practices for leveraging Next.js in our marketing site development. For content management, we will employ Contentful Cloud CMS, widely regarded as the premier headless CMS available. Contentful streamlines data management for authors and offers additional benefits that make content release to production both effortless and enjoyable. Throughout this article, we will extensively examine the features and functionalities of both Next.js and Contentful, providing detailed insights into their capabilities.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"We are committed to creating a marketing site that empowers authors to control the content as they see fit. Once the site is deployed to production, minimal intervention will be needed from the development side. Authors will have the ability to take charge, prepare, and schedule deployments for regular content updates. Furthermore, we will establish a dedicated preview environment where authors and developers can preview draft content before it goes live.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"We will ensure that our marketing site excels in SEO capability. The majority of the heavy lifting will be handled by our modern Next.js site, so our project is in good hands. We are committed to fully optimizing all media assets on our site, utilizing cutting-edge optimization techniques. To achieve this, we can rely on Next.js once again and leverage the ","marks":[],"data":{}},{"nodeType":"text","value":"Next/Image","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" component whenever images are used. In terms of SEO, our site will strictly adhere to best practices and be fully organic. To align with SEO standards, you have the flexibility to create custom fields in Contentful's content models specifically for incorporating SEO-related text. These fields can be seamlessly rendered within the application thanks to Next.js. Maintaining this setup is incredibly straightforward, provided that the content models are organically established and managed by authors.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"To build our powerful marketing site, we will break down the problem into two parts. In the first part, our focus will be on content creation. We will set up content models and create content entries based on these models for our marketing site.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"In the second part, we will integrate the data from the first part into the Next.js framework. We will explore best practices and delve into the underlying architecture of Next.js, ensuring that you gain a comprehensive understanding of how to integrate Contentful and Next.js effectively.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Once both phases are completed, we will summarize our key learnings and also explore additional features provided by Contentful that greatly facilitate the work of authors.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"As we set up our content, we will ensure that we do not create overly advanced content models that distract us from learning the core fundamentals. Our focus will be on keeping the content models simple, allowing us to thoroughly concentrate on the integration part. By the end of this article, once you have a complete understanding, the world will be yours, and you will be able to elevate your marketing sites to the next level by introducing advanced content model architectures that suit your application requirements. You will have all the necessary skills at your disposal to control the complexity right from the beginning and build a scalable marketing site.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"The source code for learning how to create solid marketing sites is available on my GitHub profile. Here is the URL: ","marks":[],"data":{}},{"nodeType":"hyperlink","data":{"uri":"https://github.com/tpkahlon/xyz-marketing-site"},"content":[{"nodeType":"text","value":"https://github.com/tpkahlon/xyz-marketing-site","marks":[],"data":{}}]},{"nodeType":"text","value":". Additionally, you can check out the final marketing site at the following URL: ","marks":[],"data":{}},{"nodeType":"hyperlink","data":{"uri":"https://xyz-marketing-site.netlify.app"},"content":[{"nodeType":"text","value":"https://xyz-marketing-site.netlify.app","marks":[],"data":{}}]},{"nodeType":"text","value":".","marks":[],"data":{}}]},{"nodeType":"heading-2","data":{},"content":[{"nodeType":"text","value":"Contentful","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Let's focus on the first part, which is about creating content in Contentful. In this section, our goal is to set up data for our marketing site. We aim to have a website with a heading and nested pages. In our marketing site, we will include a ","marks":[],"data":{}},{"nodeType":"text","value":"navigation menu","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", ","marks":[],"data":{}},{"nodeType":"text","value":"home page","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and two dynamic pages: ","marks":[],"data":{}},{"nodeType":"text","value":"About Us","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and ","marks":[],"data":{}},{"nodeType":"text","value":"Our Work","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". On the home page, there will be a navigation menu featuring a ","marks":[],"data":{}},{"nodeType":"text","value":"Home","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" link, as well as links to two dynamic pages: ","marks":[],"data":{}},{"nodeType":"text","value":"About Us","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and ","marks":[],"data":{}},{"nodeType":"text","value":"Our Work","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". Users can also directly access the dynamic pages using their respective URLs, such as ","marks":[],"data":{}},{"nodeType":"text","value":"/page/our-work","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and ","marks":[],"data":{}},{"nodeType":"text","value":"/page/about-us","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":".","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"For the purpose of understanding the foundational coupling of Next.js and Contentful, we will keep our data minimal.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"To get started, we need to create an account with Contentful. Head to ","marks":[],"data":{}},{"nodeType":"text","value":"contentful.com","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and locate the ","marks":[],"data":{}},{"nodeType":"text","value":"sign-up","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" section. Fill out all the required information, proceed and your Cloud CMS account will be up and running in a short time.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Once you have your basic CMS set up, navigate to the ","marks":[],"data":{}},{"nodeType":"text","value":"content model","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" area. In the ","marks":[],"data":{}},{"nodeType":"text","value":"content model","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" area, we will create two models: ","marks":[],"data":{}},{"nodeType":"text","value":"Site","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and ","marks":[],"data":{}},{"nodeType":"text","value":"Page","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". These content models will serve as the basis for creating content entries.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Create a new content model called ","marks":[],"data":{}},{"nodeType":"text","value":"Page","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". In this model, add a new field named ","marks":[],"data":{}},{"nodeType":"text","value":"Name","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and set its type to ","marks":[],"data":{}},{"nodeType":"text","value":"Short text","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". Repeat the process and create another field named ","marks":[],"data":{}},{"nodeType":"text","value":"Slug","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" with a type of ","marks":[],"data":{}},{"nodeType":"text","value":"Short text","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". Finally, create a field named ","marks":[],"data":{}},{"nodeType":"text","value":"Body","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" with a type of ","marks":[],"data":{}},{"nodeType":"text","value":"Rich text","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". After completing these steps, click on the ","marks":[],"data":{}},{"nodeType":"text","value":"Settings","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" link next to the ","marks":[],"data":{}},{"nodeType":"text","value":"Name","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" field, check the option ","marks":[],"data":{}},{"nodeType":"text","value":"This field represents the Entry title","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", and save the changes. Save the ","marks":[],"data":{}},{"nodeType":"text","value":"Page","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" content type. Using this content model template, let's create a few content entries.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Navigate to the ","marks":[],"data":{}},{"nodeType":"text","value":"Content","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" tab and add two pages based on the ","marks":[],"data":{}},{"nodeType":"text","value":"Page","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" content type. Set the name of the first page to ","marks":[],"data":{}},{"nodeType":"text","value":"About Us","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", the slug to ","marks":[],"data":{}},{"nodeType":"text","value":"about-us","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", and fill the ","marks":[],"data":{}},{"nodeType":"text","value":"Body","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" field with some lorem ipsum text. Create another page entry and set the name to ","marks":[],"data":{}},{"nodeType":"text","value":"Our Work","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", slug to ","marks":[],"data":{}},{"nodeType":"text","value":"our-work","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", and again, fill the ","marks":[],"data":{}},{"nodeType":"text","value":"Body","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" field with some lorem ipsum text.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Create a new content model called ","marks":[],"data":{}},{"nodeType":"text","value":"Site","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". In this model, add a field named ","marks":[],"data":{}},{"nodeType":"text","value":"Title","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" with a type of ","marks":[],"data":{}},{"nodeType":"text","value":"Short text","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". Click on the ","marks":[],"data":{}},{"nodeType":"text","value":"Settings","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" link next to the ","marks":[],"data":{}},{"nodeType":"text","value":"Title","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" field, check the option ","marks":[],"data":{}},{"nodeType":"text","value":"This field represents the Entry title","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", and save the changes. Add another field to the ","marks":[],"data":{}},{"nodeType":"text","value":"Site","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" content model and name it ","marks":[],"data":{}},{"nodeType":"text","value":"Pages","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". Set the field type to ","marks":[],"data":{}},{"nodeType":"text","value":"References","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". Choose ","marks":[],"data":{}},{"nodeType":"text","value":"many references","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" option. In the validation tab, check the ","marks":[],"data":{}},{"nodeType":"text","value":"Accept only specified entry type","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" option and select ","marks":[],"data":{}},{"nodeType":"text","value":"Page","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" as the specified entry type. Save the changes.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Head back to the ","marks":[],"data":{}},{"nodeType":"text","value":"content","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" area. Create a new content entry for the ","marks":[],"data":{}},{"nodeType":"text","value":"Site","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" content model. Give it a name like ","marks":[],"data":{}},{"nodeType":"text","value":"Welcome to XYZ Company","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". In the ","marks":[],"data":{}},{"nodeType":"text","value":"Pages","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" field, add references to the two pages we previously created, namely ","marks":[],"data":{}},{"nodeType":"text","value":"about-us","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and ","marks":[],"data":{}},{"nodeType":"text","value":"our-work","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" pages.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Publish all the content entries in Contentful to make them live.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"By following these steps, we have now created the necessary content models and content entries for your marketing sites in Contentful.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Let's summarize our progress so far. We have setup a Contentful cloud CMS to host data for our marketing site. The CMS includes two content models: ","marks":[],"data":{}},{"nodeType":"text","value":"site","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and ","marks":[],"data":{}},{"nodeType":"text","value":"page","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". Using these content models, we have created content entries for two pages and one site.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"We have successfully associated the two pages with the site entry. As a result, our site entry now contains all the necessary information to showcase the data on our application, including all relevant pages that users can visit on the marketing site.","marks":[],"data":{}}]},{"nodeType":"heading-2","data":{},"content":[{"nodeType":"text","value":"Next.js","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Let's shift our focus to the second leg of our journey. In this section, we will delve into Next.js and explore how we can utilize our cloud-based Contentful CMS to integrate it into our web application. We will leverage the data-sets from Contentful to dynamically create pages in Next.js. Our primary objective is to create a ","marks":[],"data":{}},{"nodeType":"text","value":"home page","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and two child pages: ","marks":[],"data":{}},{"nodeType":"text","value":"About Us","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and ","marks":[],"data":{}},{"nodeType":"text","value":"Our Work","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":".","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"First, let's set up a boilerplate Next.js source code to build our application. We'll be using ","marks":[],"data":{}},{"nodeType":"text","value":"create-next-app","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", which is a script that helps accelerate application development by providing pre-configured files to start with.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"npx create-next-app xyz-marketing-site","marks":[{"type":"code"}],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Let's understand the command above. ","marks":[],"data":{}},{"nodeType":"text","value":"npx create-next-app","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" will set up the starter files for our Next.js application. It will install the necessary dependencies such as Next, React, and React DOM. Additionally, it will provide us with some sample starter scripts that we can use to run and build our site. ","marks":[],"data":{}},{"nodeType":"text","value":"xyz-marketing-site","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" is the folder name where all these files will be set up. So, go ahead and run this script in your terminal.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Once the script finishes running, you will find a new folder named ","marks":[],"data":{}},{"nodeType":"text","value":"xyz-marketing-site","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" in the directory where you executed the script. To analyze the important parts that are relevant to you, open this folder in Visual Studio Code.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"The primary focus should be on the ","marks":[],"data":{}},{"nodeType":"text","value":"pages","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" folder, as it contains the key elements of our marketing site. Inside the ","marks":[],"data":{}},{"nodeType":"text","value":"pages","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" folder, you will come across the following files:","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"_app.js","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":": This file acts as the skin of your marketing site. It is referenced by every page on your site. Consider this file as a suitable location for global-level components like navigation and footer. Any component that appears throughout the entire application should be placed here. Additionally, you can utilize this file to initialize the context API, which helps manage application-wide states.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"_document.js","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":": This file can be regarded as the clothing on your skin. Within this file, you can load third-party scripts that are required across your application. You can also define meta tags that apply to the entire application.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"index.js","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":": This file represents the home page of our marketing site. Any content specifically related to the home page should be placed here.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Let's also discuss the different types of scripts that can be run in a Next.js application.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"The first script we can use is ","marks":[],"data":{}},{"nodeType":"text","value":"npm run dev","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". This script starts the development environment locally, allowing us to preview our site at ","marks":[],"data":{}},{"nodeType":"text","value":"localhost:3000","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". It is particularly useful for developers who are creating features on a static marketing site, as it enhances the development experience. In the development environment, you can also preview draft content, which is beneficial for authors when adding unapproved content to the marketing site. They can proof-check this content as soon as they create content entries in Contentful.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"The next scripts we can use are ","marks":[],"data":{}},{"nodeType":"text","value":"npm run build","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and ","marks":[],"data":{}},{"nodeType":"text","value":"npm start","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". These scripts are intended for use in the production environment. Once our application is ready to be deployed, we can utilize these scripts to build the site pages and generate static assets such as CSS, JS, and HTML files. After the static files are prepared, we can run a static server that points to these files, allowing users to view our static marketing site.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Now that you understand the backbone of a Next.js application, let's integrate Cloud Contentful CMS into our Next.js framework and make progress in preparing our marketing site. Our objective is to retrieve the site entry we created earlier from the Contentful cloud CMS. This site entry contains all the content for the entire site, including the site title and pages. We will fetch this entry and store it in a JSON file.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Once we have this JSON file available, we can reference it in Next.js to create pages for our marketing site. By following this approach, we won't be dependent on Contentful APIs. We make a call to their API once, capture all the information in the first instance, and preserve it for later use. This way, our static marketing site will be faster and more efficient.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Let's start by making a call to Cloud Contentful CMS to download the site entry locally, so that we can use it in our application. I will provide you with a source code snippet that you can use to make the API call to Cloud Contentful CMS and download the data locally. See following sample source code below.","marks":[],"data":{}}]},{"nodeType":"blockquote","data":{},"content":[{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"const fs = require(\"fs\");\nconst { createClient } = require(\"contentful\");\nconst { ENVIRONMENT } = process.env;\n\nconst options = ENVIRONMENT === \"local\"\n  ? {\n    space: \"r49vq52m78n1\",\n    environment: \"master\",\n    accessToken: \"Ol2OKd4p5qwraLY141KkC333OqxA9xr1q9HpulMDJj8\",\n    host: \"preview.contentful.com\",\n  }\n  : {\n    space: \"r49vq52m78n1\",\n    environment: \"master\",\n    accessToken: \"WEf_mYYcgw0A0YIl7shf34UptpKnwBpfbxje6RXrC5o\",\n  };\n\nconst client = createClient(options);\n\nclient.withoutUnresolvableLinks.getEntries().then((data) => {\n  const [siteEntry] = data.items.filter((entry) => entry.sys.contentType.sys.id === \"site\");\n  const jsonString = JSON.stringify(siteEntry);\n  const filePath = \"./public/data.json\";\n  fs.writeFile(filePath, jsonString, (err) => {\n    if (err) {\n      console.error(\"Failed to save JSON data:\", err);\n    } else {\n      console.log(\"JSON data saved to file:\", filePath);\n    }\n  });\n});","marks":[],"data":{}}]}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"In the provided code file, we are utilizing the ","marks":[],"data":{}},{"nodeType":"text","value":"fs","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" library from Node.js to access the file system and the ","marks":[],"data":{}},{"nodeType":"text","value":"contentful","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" library to interact with Cloud Contentful CMS. To proceed, we need to obtain the ","marks":[],"data":{}},{"nodeType":"text","value":"Space ID","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and ","marks":[],"data":{}},{"nodeType":"text","value":"Access Token","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" from the Contentful Cloud CMS. You can find these keys in the ","marks":[],"data":{}},{"nodeType":"text","value":"Settings","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" area of your Contentful account by clicking on ","marks":[],"data":{}},{"nodeType":"text","value":"API Keys","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". In the ","marks":[],"data":{}},{"nodeType":"text","value":"Content Delivery/Preview Tokens","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" section, open an existing key to locate the ","marks":[],"data":{}},{"nodeType":"text","value":"Content Delivery API","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" key, ","marks":[],"data":{}},{"nodeType":"text","value":"Preview API","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" key, and ","marks":[],"data":{}},{"nodeType":"text","value":"Space ID","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":".","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"The basic idea is to configure the connection to Cloud Contentful CMS using the ","marks":[],"data":{}},{"nodeType":"text","value":"createClient","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" method. This method requires different options depending on the ","marks":[],"data":{}},{"nodeType":"text","value":"ENVIRONMENT","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" variable. If the ","marks":[],"data":{}},{"nodeType":"text","value":"ENVIRONMENT","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" is set to ","marks":[],"data":{}},{"nodeType":"text","value":"local","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", we make a call to the Preview API, which is helpful during development. If the ","marks":[],"data":{}},{"nodeType":"text","value":"ENVIRONMENT","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" is not set, we treat it as the production-level option and make a call to the Delivery API.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"We are also employing the ","marks":[],"data":{}},{"nodeType":"text","value":"withoutUnresolvableLinks","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" method to ensure that any content entries or references originating from Contentful are skipped from the delivery API if they are in a draft state.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Once the connection is established, we retrieve all the entries from Cloud Contentful CMS using the ","marks":[],"data":{}},{"nodeType":"text","value":"getEntries","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" method. After obtaining all the entries, we filter out the site entry. Once the site entry is found, we dynamically create a JSON file and store it in the ","marks":[],"data":{}},{"nodeType":"text","value":"public","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" folder.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Additionally, we need to make a minor change in the Next.js scripts. We will modify the ","marks":[],"data":{}},{"nodeType":"text","value":"dev","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and ","marks":[],"data":{}},{"nodeType":"text","value":"build","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" scripts to include the ","marks":[],"data":{}},{"nodeType":"text","value":"npm run data","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" script. The ","marks":[],"data":{}},{"nodeType":"text","value":"dev","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" script will become ","marks":[],"data":{}},{"nodeType":"text","value":"npm run data && next dev","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", and the ","marks":[],"data":{}},{"nodeType":"text","value":"build","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" script will become ","marks":[],"data":{}},{"nodeType":"text","value":"npm run data && next build","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". This ensures that regardless of whether we are running the development or production environment, we always fetch the latest data from Contentful CMS.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"To implement the above instructions, please follow these steps:","marks":[],"data":{}}]},{"nodeType":"ordered-list","data":{},"content":[{"nodeType":"list-item","data":{},"content":[{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Copy the provided code snippet to a file named ","marks":[],"data":{}},{"nodeType":"text","value":"index.js","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and save the file in the ","marks":[],"data":{}},{"nodeType":"text","value":"contentful","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" folder at the root level of your application.","marks":[],"data":{}}]}]},{"nodeType":"list-item","data":{},"content":[{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Add a new script in the ","marks":[],"data":{}},{"nodeType":"text","value":"package.json","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" file and name it ","marks":[],"data":{}},{"nodeType":"text","value":"data","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" with a value of ","marks":[],"data":{}},{"nodeType":"text","value":"node contentful","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". This script will instruct the Node.js server to compile the ","marks":[],"data":{}},{"nodeType":"text","value":"index.js","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" file located in the ","marks":[],"data":{}},{"nodeType":"text","value":"contentful","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" folder.","marks":[],"data":{}}]}]}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Once you have completed these steps, you should be able to make the necessary API call to Cloud Contentful CMS and download the data locally for your application.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Let's start integrating the downloaded data into our pages. First, we need to set up the home page. Please refer to the source code below.","marks":[],"data":{}}]},{"nodeType":"blockquote","data":{},"content":[{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"import Head from \"next/head\";\nimport data from \"../public/data.json\";\n\nexport default function Home() {\n  const siteTitle = data.fields.title;\n  return (\n    <>\n      <Head>\n        <title>{siteTitle}</title>\n      </Head>\n      <main>\n        <h1>{siteTitle}</h1>\n      </main>\n    </>\n  )\n};","marks":[],"data":{}}]}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"In this code, you can see that our home page is now rendering the ","marks":[],"data":{}},{"nodeType":"text","value":"title","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" that is defined within the Contentful.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"When users visit our application at ","marks":[],"data":{}},{"nodeType":"text","value":"localhost:3000","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", they will be greeted with this text, which is dynamically injected into the page and comes from the Cloud CMS.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Now, let's set up a navigation for the application where we will create links to our different pages. Please refer to the source code below.","marks":[],"data":{}}]},{"nodeType":"blockquote","data":{},"content":[{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"import Link from \"next/link\";\nimport data from \"../public/data.json\";\n\nfunction MyApp({ Component, pageProps }) {\n  return (\n    <>\n      <nav>\n        <Link href=\"/\">Home</Link>\n        {data.fields.pages.map(page => (\n          <Link key={page.sys.id} href={`/page/${page.fields.slug}`}>{page.fields.name}</Link>\n         ))}\n      </nav>\n      <Component {...pageProps} />\n    </>\n  )\n};\n\nexport default MyApp;","marks":[],"data":{}}]}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"In this code, you will notice that we are looping over the downloaded data and creating menu items for our navigation. These menu items will lead to a relative path named ","marks":[],"data":{}},{"nodeType":"text","value":"/page","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" followed by the page slug, which is retrieved from the Cloud Contentful CMS.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"If you try to access these pages from a browser now, they will not work immediately because we have not set up a dynamic page template for the ","marks":[],"data":{}},{"nodeType":"text","value":"page","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" relative path. Let's do this next. In the ","marks":[],"data":{}},{"nodeType":"text","value":"pages","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" folder, create a new folder named ","marks":[],"data":{}},{"nodeType":"text","value":"page","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". Inside this folder, create a file named ","marks":[],"data":{}},{"nodeType":"text","value":"[...slug].js","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and use the following source code in it.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"When a user tries to visit the ","marks":[],"data":{}},{"nodeType":"text","value":"/page/xyz/abc","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" path in the browser, the information ","marks":[],"data":{}},{"nodeType":"text","value":"xyz","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and ","marks":[],"data":{}},{"nodeType":"text","value":"abc","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" will be captured in this dynamic page template named","marks":[],"data":{}},{"nodeType":"text","value":" [...slug].js","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" file in the form of an array. For this dynamic template, we will inform Next.js that we already have two pages available in Cloud CMS. Use the slug names for those two pages, create them on the fly, and pass them to users when the path matches. If not, provide a ","marks":[],"data":{}},{"nodeType":"text","value":"404","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" page to the user.","marks":[],"data":{}}]},{"nodeType":"blockquote","data":{},"content":[{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"import Head from \"next/head\";\nimport { documentToReactComponents } from \"@contentful/rich-text-react-renderer\";\nimport data from \"../../public/data.json\";\n\nexport function getStaticPaths() {\n  const paths = data.fields.pages.map(({ fields: { slug } }) => {\n    return {\n      params: {\n        slug: [slug],\n      },\n    };\n  });\n  return {\n    paths,\n    fallback: false,\n  };\n}\n\nexport function getStaticProps({ params }) {\n  const [page] = data.fields.pages.filter(({ fields: { slug } }) => {\n    return slug === params.slug.join(\"\");\n  });\n  return {\n    props: {\n      page,\n    },\n  };\n}\n\nexport default function Home(props) {\n  const pageName = props.page.fields.name;\n  return (\n    <>\n     <Head><title>{pageName}</title></Head>\n     <main>\n       <h1>{pageName}</h1>\n       <div>{documentToReactComponents(props.page.fields.body)}</div>\n     </main>\n   </>\n  );\n}","marks":[],"data":{}}]}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Let's understand the architecture of a dynamic page from the above source code.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"We have a ","marks":[],"data":{}},{"nodeType":"text","value":"getStaticPaths","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" function. In this function, we generate possible combinations of slugs that exist in our Cloud CMS data. We are generating combinations for the ","marks":[],"data":{}},{"nodeType":"text","value":"about-us","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and ","marks":[],"data":{}},{"nodeType":"text","value":"our-work","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" pages using this function. We also define a ","marks":[],"data":{}},{"nodeType":"text","value":"fallback","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" option, which means if the slug requested by users does not match the existing ones, a ","marks":[],"data":{}},{"nodeType":"text","value":"404","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" page will be sent to the users. The return type of this function is an object with key-value pairs of ","marks":[],"data":{}},{"nodeType":"text","value":"paths","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and ","marks":[],"data":{}},{"nodeType":"text","value":"fallback","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". The ","marks":[],"data":{}},{"nodeType":"text","value":"paths","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" value is always going to be an array.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Next, we have a ","marks":[],"data":{}},{"nodeType":"text","value":"getStaticProps","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" function. In this function, we locate the data for the matching path. Let's assume that if a user tries to visit the ","marks":[],"data":{}},{"nodeType":"text","value":"/page/about-us","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" page, because this page do exists in the Contentful CMS, we filter the data-set for this slug and then pass the data-set to the main function, where we will render the information such as the page name, page body, etc. The return type of this function is an object with a key of ","marks":[],"data":{}},{"nodeType":"text","value":"props","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", where ","marks":[],"data":{}},{"nodeType":"text","value":"props","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" is always going to be an object.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Finally, we have the default exported function, which will render the matching data on the dynamic page.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"In the dynamic page, we are also utilizing a React component to render the rich text data present in the Contentful CMS. That's why you will notice the usage of ","marks":[],"data":{}},{"nodeType":"text","value":"@contentful/rich-text-react-renderer","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" in the dynamic page file.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"With these updates, all the pages on our static marketing site are now fully functional. Our home page displays unique content, and we have dynamic pages accessible through the relative path ","marks":[],"data":{}},{"nodeType":"text","value":"/page/","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" with their respective unique slugs. When we visit these pages, the content renders correctly for ","marks":[],"data":{}},{"nodeType":"text","value":"/page/about-us","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and ","marks":[],"data":{}},{"nodeType":"text","value":"/page/our-work","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" pages.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"To view draft pages locally, you can run the development script using the command ","marks":[],"data":{}},{"nodeType":"text","value":"ENVIRONMENT=local npm run dev","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". This allows you to preview any new pages added by authors, which they plan to launch on the production site in the near future. As long as authors have attached these new pages to the site's content entry, you can easily view them locally without the need to publish anything. These mock pages can remain in a draft state but will be visible in the development environment. This feature greatly simplifies proof-checking and testing before launching updates.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"If you run the development script without specifying the ","marks":[],"data":{}},{"nodeType":"text","value":"ENVIRONMENT","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" variable, you will continue to see only published content.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Congratulations! If you've managed to read both sections of this article, you have successfully set up a solid marketing site that is fully static and lightning-fast. This site is independent of the Cloud Contentful CMS API, as all the data is available locally. There are two types of preview environments available, which can be easily toggled using the ","marks":[],"data":{}},{"nodeType":"text","value":"ENVIRONMENT","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" variable.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Now, let's make our static site more automated for our authors. Before proceeding, it's recommended to host your Next.js application somewhere. Examples of hosting providers include Netlify, GitLab, and Vercel. The choice of hosting platform is up to you. Once you have deployed your Next.js application's source code, we can set up a web-hook in Contentful.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Contentful provides great convenience, especially if you are using a popular hosting provider like Netlify or Vercel. In the Web-hook section of Contentful, you will find ready-made templates that can be integrated with these hosting providers. Alternatively, you can set up a custom web-hook. Let's assume that you have uploaded your application's source code on GitHub and created a site via Netlify. We can create a web-hook that listens to authors' activity in Contentful. Whenever an author publishes or unpublishes a content entry, content model, or media item, we can trigger a deployment that will upload the latest data to production site.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Additionally, authors can make use of the concept of ","marks":[],"data":{}},{"nodeType":"text","value":"Releases","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", ","marks":[],"data":{}},{"nodeType":"text","value":"Scheduled actions","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and ","marks":[],"data":{}},{"nodeType":"text","value":"Bulk actions","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" when preparing for a major content release. These publishing methods give authors more power, allowing them to schedule a launch for their content changes according to their timelines.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"This enables authors to easily manage the site's content without relying heavily on developers. Once all the essential features are implemented, authors have the freedom to assume control and personalize the site to suit their specific requirements.","marks":[],"data":{}}]},{"nodeType":"heading-2","data":{},"content":[{"nodeType":"text","value":"Conclusion","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"In the end, I hope you have gained a better understanding of the overall architecture required for a robust marketing site. By following these foundational principles, you will be able to develop efficient, responsive, and future-proof marketing sites. Additionally, adhering to these principles will make life easier for authors. In this article, we have used minimal sizing of content models to provide a comprehensive view of the intricacies behind the scenes. Now that you are aware of what goes on behind the scenes, you can effectively manage the complexity of marketing sites and ensure they remain simple and efficient.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"One recommendation I have is to keep the design of content models as simple and organic as possible. Try to follow the DRY (Don't Repeat Yourself) principle and eliminate redundancy. By making the architecture of your content models more efficient, the outcome will directly reflect on your marketing site, and maintenance will become more linear and seamless. Try to come up with smart approaches to avoid circular references in Contentful. Utilize the power of JavaScript higher-order functions to filter specific data-sets from your site's entry content whenever you encounter circular references. Over time, as you practice the art of developing marketing sites, you will develop habits on how to best maneuver those decisions to maintain a simpler architecture.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Now that we have covered the basic fundamentals of showing the home page and dynamic pages using a page template, you can customize this marketing site to meet your business needs. For example, if you want to display products on your marketing site, you can create a ","marks":[],"data":{}},{"nodeType":"text","value":"Product","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" content model in Contentful and attach a ","marks":[],"data":{}},{"nodeType":"text","value":"Products","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" field to the ","marks":[],"data":{}},{"nodeType":"text","value":"Site","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" content model. This will allow you to attach all the products you want to showcase on the marketing site to the site content entry. The possibilities are endless, and you can have as many dynamic page templates as you need.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"You can also start thinking about filtering options. Let's say you want to write articles on the marketing site, and each article should have a unique tag associated with it. Based on this tag, you want to display a custom set of articles that are associated with the same tag. To achieve this, you can have a ","marks":[],"data":{}},{"nodeType":"text","value":"Tag","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" content type in Contentful and add a new field to the ","marks":[],"data":{}},{"nodeType":"text","value":"Article","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" content model where you can include unique tags for each article. Then, you can build dynamic pages in Next.js to showcase these articles and more.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Furthermore, consider creating reusable content models in Contentful that authors can utilize to build layouts for specific pages. You can create a set of custom content models that authors and designers can use to create unique layouts on the page.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Additionally, you can create multiple sites within a single Contentful space. In the site content model, you can define a ","marks":[],"data":{}},{"nodeType":"text","value":"slug","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" field where authors can create a unique slug for each site. This allows you to reuse custom content models across various sites, promoting consistency and standardization.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Once you have established the basic foundation and built a solid framework for your marketing site, you can begin making decisions about how to implement styling. There are several options to consider, such as ","marks":[],"data":{}},{"nodeType":"text","value":"Tailwind CSS","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", ","marks":[],"data":{}},{"nodeType":"text","value":"Sass","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", or using a custom CSS framework. In my personal blog, I opted for the ","marks":[],"data":{}},{"nodeType":"text","value":"simple.css","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" framework, which automatically applies utility classes to HTML elements. The choice of styling approach is entirely up to you and can be made according to your personal preferences. Rest assured that whichever option you choose, it will not have a negative impact on the performance of your marketing site. The solid foundation we have established will remain intact, and the styling will only serve to enhance and elevate the overall product.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Another npm package that can be useful is ","marks":[],"data":{}},{"nodeType":"text","value":"contentful-cli","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", which enables you to create sandbox environments via the command line interface (CLI). This tool is particularly helpful when you need to set up different types of environments within Contentful. ","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"For instance, imagine you have a mission-critical marketing site where content is highly sensitive and requires thorough review before being deployed to production. In such scenarios, you can create a dedicated sandbox environment where you can test the features you plan to release for this site. Once your features have been thoroughly tested in the sandbox environment, you can then move them to the master environment in Contentful.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Lastly, I encourage you to check out my other article where I discuss useful NPM packages that are commonly used in the Contentful ecosystem. If you're planning to create a marketing site for your company, you can start incorporating these NPM packages into your daily development workflow. In particular, when designing and planning content models, it's beneficial to use the ","marks":[],"data":{}},{"nodeType":"text","value":"contentful-migration","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" NPM package, as it provides greater control and standardization for working with content models in Contentful.","marks":[],"data":{}}]}]}}},{"metadata":{"tags":[]},"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"rv8g4s0yjblf"}},"id":"7u6IP4T9vbajmeQNhI7aDD","type":"Entry","createdAt":"2023-05-26T02:58:24.898Z","updatedAt":"2023-05-26T03:13:13.353Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment"}},"revision":6,"contentType":{"sys":{"type":"Link","linkType":"ContentType","id":"article"}},"locale":"en-US"},"fields":{"name":"#4 - An introduction to dynamic pages in Next.js","slug":"introduction-to-dynamic-pages-in-nextjs","body":{"nodeType":"document","data":{},"content":[{"nodeType":"heading-1","data":{},"content":[{"nodeType":"text","value":"Introduction","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Next.js is a popular React framework that simplifies the process of building web applications. One of its key features is the ability to create dynamic pages, which allow for flexible and personalized content based on user input or data. In this article, we will explore the basics of dynamic pages in Next.js and cover the essential standards you need to know.","marks":[],"data":{}}]},{"nodeType":"heading-2","data":{},"content":[{"nodeType":"text","value":"Standard 1: Anonymous function","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"In Next.js, every page, whether it's a static page or a dynamic one, utilizes a default exported function. This function is responsible for rendering the markup that users will see when they visit the page. Let's take an example to illustrate this concept:","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Suppose you have an ","marks":[],"data":{}},{"nodeType":"text","value":"index.js","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" file in the ","marks":[],"data":{}},{"nodeType":"text","value":"pages","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" folder. By using the following code snippet, users will see ","marks":[],"data":{}},{"nodeType":"text","value":"\"Hello, world!\"","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" when they visit ","marks":[],"data":{}},{"nodeType":"text","value":"localhost:3000","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" while running the development server locally:","marks":[],"data":{}}]},{"nodeType":"blockquote","data":{},"content":[{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"FILE: pages/index.js","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"export default function() {\n  return <div>Hello, world!</div>;\n}","marks":[],"data":{}}]}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Similarly, dynamic pages in Next.js also employ the same default exported function. If you navigate to ","marks":[],"data":{}},{"nodeType":"text","value":"localhost:3000/page/foo","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", where ","marks":[],"data":{}},{"nodeType":"text","value":"page","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" represents a dynamic page template and ","marks":[],"data":{}},{"nodeType":"text","value":"foo","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" is a dynamic path that can change based on data, you can create a default exported function in the ","marks":[],"data":{}},{"nodeType":"text","value":"page/[slug].js ","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":"or ","marks":[],"data":{}},{"nodeType":"text","value":"page/[...slug].js","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" files.","marks":[],"data":{}}]},{"nodeType":"blockquote","data":{},"content":[{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"FILE: pages/[...slug].js | pages/[slug].js","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"export default function() {\n  return <div>Hello, world!</div>;\n}","marks":[],"data":{}}]}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"The markup returned by this function will be displayed to users visiting the corresponding dynamic page.","marks":[],"data":{}}]},{"nodeType":"heading-2","data":{},"content":[{"nodeType":"text","value":"Standard 2: getStaticPaths function","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"The ","marks":[],"data":{}},{"nodeType":"text","value":"getStaticPaths","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" function is exclusively used in dynamic pages where you intend to build pages dynamically based on slug data. Imagine you have two pages, ","marks":[],"data":{}},{"nodeType":"text","value":"about","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and ","marks":[],"data":{}},{"nodeType":"text","value":"contact","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", stored in a JSON data file. Users can visit these pages at ","marks":[],"data":{}},{"nodeType":"text","value":"localhost:3000/page/about ","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":"or","marks":[],"data":{}},{"nodeType":"text","value":" localhost:3000/page/contact","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". In this case, you can create a ","marks":[],"data":{}},{"nodeType":"text","value":"page","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" folder within the ","marks":[],"data":{}},{"nodeType":"text","value":"pages","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" directory and then create a ","marks":[],"data":{}},{"nodeType":"text","value":"[slug].js","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" file. This file captures the initial relative path parameter loaded in the URL provided by the users, serving as the dynamic value. To ensure Next.js identifies and matches these dynamic pages correctly, we need to predefine the slugs in advance.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"The ","marks":[],"data":{}},{"nodeType":"text","value":"getStaticPaths","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" function follows a specific convention. It must return an object with two keys: ","marks":[],"data":{}},{"nodeType":"text","value":"paths","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and ","marks":[],"data":{}},{"nodeType":"text","value":"fallback","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":". The ","marks":[],"data":{}},{"nodeType":"text","value":"paths","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" key holds an array of objects, where each object has a ","marks":[],"data":{}},{"nodeType":"text","value":"params","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" key. The ","marks":[],"data":{}},{"nodeType":"text","value":"params","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" key, in turn, contains a ","marks":[],"data":{}},{"nodeType":"text","value":"slug","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" key with a string value. The file structure would typically resemble ","marks":[],"data":{}},{"nodeType":"text","value":"[...slug].js","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" or ","marks":[],"data":{}},{"nodeType":"text","value":"[slug].js","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":".","marks":[],"data":{}}]},{"nodeType":"blockquote","data":{},"content":[{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"FILE: pages/[slug].js\nexport async function getStaticPaths() {\n  return {\n    paths: [\n      { params: { slug: \"about\" } },\n      { params: { slug: \"contact\" } },\n      // Additional slugs can be added here\n    ],\n    fallback: false,\n  };\n}","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"export default function() {\n  return <div>Hello World</div>;\n}","marks":[],"data":{}}]}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"With this setup, when users visit ","marks":[],"data":{}},{"nodeType":"text","value":"localhost:3000/page/about","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", the default exported function of the corresponding dynamic page will be executed, and the appropriate markup will be displayed.","marks":[],"data":{}}]},{"nodeType":"blockquote","data":{},"content":[{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"FILE: pages/[...slug].js\nexport async function getStaticPaths() {\n  return {\n    paths: [\n      { params: { slug: [\"about\"] } },\n      { params: { slug: [\"contact\"] } },\n      // Additional slugs can be added here\n    ],\n    fallback: false,\n  };\n}","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"export default function() {\n  return <div>Hello World</div>;\n}","marks":[],"data":{}}]}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"The primary distinction between ","marks":[],"data":{}},{"nodeType":"text","value":"[...slug].js","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" and ","marks":[],"data":{}},{"nodeType":"text","value":"[slug].js","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" lies in their capturing capabilities. ","marks":[],"data":{}},{"nodeType":"text","value":"[slug].js","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" captures only the first parameter in the relative path of the URL. For example, if a user visits ","marks":[],"data":{}},{"nodeType":"text","value":"localhost:3000/page/about/test","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", ","marks":[],"data":{}},{"nodeType":"text","value":"[slug].js","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" will only capture \"about\" and disregard \"test.\" On the other hand, ","marks":[],"data":{}},{"nodeType":"text","value":"[...slug].js","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" can capture all available relative paths in the URL and return them as an array.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"When you plan to use ","marks":[],"data":{}},{"nodeType":"text","value":"getStaticPaths ","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":"function in a dynamic page, make sure you also use ","marks":[],"data":{}},{"nodeType":"text","value":"getStaticProps","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" function. Both of these function goes hand in hand together.","marks":[],"data":{}}]},{"nodeType":"heading-2","data":{},"content":[{"nodeType":"text","value":"Standard 3: getStaticProps function","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Another key feature that sets Next.js apart is the ","marks":[],"data":{}},{"nodeType":"text","value":"getStaticProps","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" function, which allows developers to fetch data and pass it as props to their components.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"The presence of ","marks":[],"data":{}},{"nodeType":"text","value":"getStaticProps","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" in a Next.js application brings numerous benefits. This function serves as a bridge between the data source and the rendering logic, enabling developers to customize the content and behavior of their web pages. By utilizing this powerful feature, developers can dynamically pass additional props to the markup or anonymous functions, empowering them to create highly personalized and data-driven user experiences.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"At its core, ","marks":[],"data":{}},{"nodeType":"text","value":"getStaticProps","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" is responsible for fetching and manipulating data before rendering a page. By capturing the slug value passed from the ","marks":[],"data":{}},{"nodeType":"text","value":"getStaticPaths","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" function, developers can use this information to retrieve the exact content associated with a specific slug. Whether the data is stored in a file or a database, ","marks":[],"data":{}},{"nodeType":"text","value":"getStaticProps","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" allows developers to seamlessly integrate it into their Next.js application.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"One of the primary use cases of ","marks":[],"data":{}},{"nodeType":"text","value":"getStaticProps","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" is fetching data from external sources. Developers can make fetch calls to APIs or other external services, capturing the necessary data, and passing it along to the anonymous function. This capability opens up a world of possibilities for integrating real-time or frequently updated information into the rendered markup.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"For example, imagine you are building a blog website with Next.js. Each blog post has its own unique slug, and you want to display additional information such as the number of views, likes, or comments for each post. With ","marks":[],"data":{}},{"nodeType":"text","value":"getStaticProps","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", you can fetch this data from an external analytics service or your own backend API, and then pass it as props to the anonymous function responsible for rendering the blog post. This way, you can seamlessly incorporate dynamic data into your statically generated pages.","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"To illustrate the practical implementation of ","marks":[],"data":{}},{"nodeType":"text","value":"getStaticProps","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":", let's consider a simplified code snippet:","marks":[],"data":{}}]},{"nodeType":"blockquote","data":{},"content":[{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"// pages/blog/[slug].js","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"import { getContentBySlug } from 'some-data-source';","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"export async function getStaticPaths() {\n  // Generate paths for all blog posts\n  const slugs = await getAllBlogPostSlugs();\n  const paths = slugs.map((slug) => ({ params: { slug } }));","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"  return {\n    paths,\n    fallback: false\n  };\n}","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"export async function getStaticProps({ params }) {\n  // Fetch content based on the slug\n  const content = await getContentBySlug(params.slug);","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"  return {\n    props: {\n      content,\n    }\n  };\n}","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"export default function BlogPost({ content }) {\n  return (\n    <div>\n      <h1>{content.title}</h1>\n      <p>{content.body}</p>\n    </div>\n  );\n}","marks":[],"data":{}}]}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"In the above example, the ","marks":[],"data":{}},{"nodeType":"text","value":"getStaticPaths","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" function generates the paths for all the blog posts by fetching their slugs. This ensures that each blog post has a dedicated URL and can be statically generated at build time. The ","marks":[],"data":{}},{"nodeType":"text","value":"getStaticProps","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" function fetches the content associated with the specific slug and also retrieves additional data from an external source. The fetched data is then passed as props to the ","marks":[],"data":{}},{"nodeType":"text","value":"BlogPost","marks":[{"type":"code"}],"data":{}},{"nodeType":"text","value":" component.","marks":[],"data":{}}]},{"nodeType":"heading-2","data":{},"content":[{"nodeType":"text","value":"Conclusion","marks":[],"data":{}}]},{"nodeType":"paragraph","data":{},"content":[{"nodeType":"text","value":"Understanding the basics of dynamic pages in Next.js is crucial for building interactive and personalized web applications. By leveraging the default exported function and rendering dynamic content based on user input or data, you can create powerful and engaging experiences. We covered the first standard, which is the usage of anonymous functions, in this article. Stay tuned for the upcoming parts, where we will explore more conventions and techniques for working with dynamic pages in Next.js.","marks":[],"data":{}}]}]}}}]}}